(define (cons a b) (cons a b))
(define (pair? x) (pair? x))
(define (+ a b) (+ a b))
(define (- a b) (- a b))
(define (* a b) (* a b))
(define (/ a b) (/ a b))
(define (= a b) (= a b))
(define (< a b) (< a b))
(define (<= a b) (<= a b))
(define (> a b) (> a b))
(define (>= a b) (>= a b))

(define (car x) (car x))
(define (cdr x) (cdr x))

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (list . lst)
  lst)

(define (zero? x)
  (= x 0))

(define (positive? x)
  (> x 0))

(define (negative? x)
  (< x 0))

(define (abs x)
  (if (positive? x)
      x
      (- 0 x)))

(define (quotient a b)
  (quotient a b))

(define (sys:sign x)
  (if (>= x 0)
      1
      -1))

(define (remainder a b)
  (* (sys:sign a)
     (abs (sys:imod a b))))

(define (modulo a b)
  (if (= (sys:sign a) (sys:sign b))
      (sys:imod a b)
      (+ b (sys:imod a b))))

(define (even? x)
  (zero? (remainder x 2)))

(define (odd? x)
  (= 1 (remainder x 2)))

(define (not x)
  (if x
      #f
      #t))

(define (reverse lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (cons (car current) acc) (cdr current))
        acc))
  (iter nil lst))

(define (map f lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (cons (f (car current)) acc) (cdr current))
        (reverse acc)))
  (iter nil lst))

(define (filter f lst)
  (define (iter acc current)
    (if (pair? current)
        (if (f (car current))
            (iter (cons (car current) acc) (cdr current))
            (iter acc (cdr current)))
        (reverse acc)))
  (iter nil lst))

(define (fold f acc lst)
  (if (pair? lst)
      (fold f (f acc (car lst)) (cdr lst))
      acc))

(define (range from to . rest)
  (define (iter acc current step)
    (if (> current to)
        (reverse acc)
        (iter (cons current acc) (+ current step) step)))
  (iter nil
        from
        (if (pair? rest)
            (car rest)
            1)))

(define (all? f lst)
  (define (iter current)
    (if (pair? current)
        (if (f (car current))
            (iter (cdr current))
            #f)
        #t))
  (iter lst))

(define (any? f lst)
  (define (iter current)
    (if (pair? current)
        (if (f (car current))
            #t
            (iter (cdr current)))
        #f))
  (iter lst))

(define (length lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (+ 1 acc) (cdr current))
        acc))
  (iter 0 lst))

(define (list-tail lst k)
  (if (zero? k)
      lst
      (list-tail (cdr lst) (- k 1))))

(define (list-ref lst k)
  (car (list-tail lst k)))

(define (sys:gcd-of-two a b)
  (if (= b 0)
      a
      (sys:gcd-of-two b (remainder a b))))

(define (gcd . args)
  (if (zero? (length args))
      0
      (abs (fold sys:gcd-of-two (car args) (cdr args)))))

(define (sys:lcm-of-two a b)
  (/ (* a b)
     (sys:gcd-of-two a b)))

(define (lcm . args)
  (if (zero? (length args))
      1
      (abs (fold sys:lcm-of-two (car args) (cdr args)))))
