(define (cons a b) (cons a b))
(define (pair? x) (pair? x))
(define (+ a b) (+ a b))
(define (- a b) (- a b))
(define (* a b) (* a b))
(define (/ a b) (/ a b))
(define (= a b) (= a b))
(define (< a b) (< a b))
(define (<= a b) (<= a b))
(define (> a b) (> a b))
(define (>= a b) (>= a b))
(define (random x) (random x))
(define (eq? a b) (eq? a b))
(define (null? x) (null? x))
(define (display x) (display x))
(define (car x) (car x))
(define (cdr x) (cdr x))
(define (string? x) (string? x))
(define (number? x) (number? x))
(define (char? x) (char? x))
(define (char=? a b) (char=? a b))
(define (char>? a b) (char>? a b))
(define (char<? a b) (char<? a b))
(define (char-ci=? a b) (char-ci=? a b))
(define (char-ci>? a b) (char-ci>? a b))
(define (char-ci<? a b) (char-ci<? a b))
(define (string=? a b) (string=? a b))
(define (string>? a b) (string>? a b))
(define (string<? a b) (string<? a b))
(define (string-ci=? a b) (string-ci=? a b))
(define (string-ci>? a b) (string-ci>? a b))
(define (string-ci<? a b) (string-ci<? a b))
(define (string-length x) (string-length x))
(define (substring str start end) (substring str start end))
(define (string-append a b) (string-append a b))
(define (quotient a b) (quotient a b))
(define (char->integer x) (char->integer x))
(define (integer->char x) (integer->char x))
(define (string-ref str k) (string-ref str k))
(define (string-set! str k c) (string-set! str k c))
(define (string->symbol x) (string->symbol x))
(define (symbol->string x) (symbol->string x))
(define (boolean? x) (boolean? x))
(define (symbol? x) (symbol? x))
(define (integer? x) (integer? x))
(define (real? x) (real? x))

(define (char>=? a b) (not (char<? a b)))
(define (char<=? a b) (not (char>? a b)))
(define (char-ci>=? a b) (not (char-ci<? a b)))
(define (char-ci<=? a b) (not (char-ci>? a b)))
(define (string>=? a b) (not (string<? a b)))
(define (string<=? a b) (not (string>? a b)))
(define (string-ci>=? a b) (not (string-ci<? a b)))
(define (string-ci<=? a b) (not (string-ci>? a b)))

(define (newline) (display "\n"))

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (list . lst) lst)
(define (zero? x) (= x 0))
(define (positive? x) (> x 0))
(define (negative? x) (< x 0))

(define (error . params) (sys:error params))

(define (abs x)
  (if (positive? x)
      x
      (- 0 x)))

(define (sys:sign x)
  (if (>= x 0) 1 -1))

(define (remainder a b)
  (* (sys:sign a)
     (abs (sys:imod a b))))

(define (modulo a b)
  (if (= (sys:sign a) (sys:sign b))
      (sys:imod a b)
      (+ b (sys:imod a b))))

(define (even? x)
  (zero? (remainder x 2)))

(define (odd? x)
  (= 1 (remainder x 2)))

(define (not x)
  (if x #f #t))

(define (reverse lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (cons (car current) acc) (cdr current))
        acc))
  (iter nil lst))

(define (map f lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (cons (f (car current)) acc) (cdr current))
        (reverse acc)))
  (iter nil lst))

(define (for-each f lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (f (car current)) (cdr current))
        #t))
  (iter nil lst))

(define (filter f lst)
  (define (iter acc current)
    (if (pair? current)
        (if (f (car current))
            (iter (cons (car current) acc) (cdr current))
            (iter acc (cdr current)))
        (reverse acc)))
  (iter nil lst))

(define (fold f acc lst)
  (if (pair? lst)
      (fold f (f acc (car lst)) (cdr lst))
      acc))

(define (range from to . rest)
  (define (iter acc current step)
    (if (>= current to)
        (reverse acc)
        (iter (cons current acc) (+ current step) step)))
  (iter nil
        from
        (if (pair? rest)
            (car rest)
            1)))

(define (all? f lst)
  (define (iter current)
    (if (pair? current)
        (if (f (car current))
            (iter (cdr current))
            #f)
        #t))
  (iter lst))

(define (any? f lst)
  (define (iter current)
    (if (pair? current)
        (if (f (car current))
            #t
            (iter (cdr current)))
        #f))
  (iter lst))

(define (length lst)
  (define (iter acc current)
    (if (pair? current)
        (iter (+ 1 acc) (cdr current))
        acc))
  (iter 0 lst))

(define (list-tail lst k)
  (if (zero? k)
      lst
      (list-tail (cdr lst) (- k 1))))

(define (list-ref lst k)
  (car (list-tail lst k)))

(define (sys:gcd-of-two a b)
  (if (= b 0)
      a
      (sys:gcd-of-two b (remainder a b))))

(define (gcd . args)
  (if (zero? (length args))
      0
      (abs (fold sys:gcd-of-two (car args) (cdr args)))))

(define (sys:lcm-of-two a b)
  (/ (* a b)
     (sys:gcd-of-two a b)))

(define (lcm . args)
  (if (zero? (length args))
      1
      (abs (fold sys:lcm-of-two (car args) (cdr args)))))

(define (char-whitespace? c)
  (cond ((char=? c #\space) #t)
        ((char=? c #\newline) #t)
        ((char=? c #\cr) #t)
        ((char=? c #\tab) #t)
        (else #f)))

(define (char-alphabetic? c)
  (if (char-ci>=? c #\a)
      (char-ci<=? c #\z)
      #f))

(define (char-numeric? c)
  (if (char-ci>=? c #\0)
      (char-ci<=? c #\9)
      #f))

(define (char-upper-case? c)
  (if (char>=? c #\A)
      (char<=? c #\Z)
      #f))

(define (char-lower-case? c)
  (if (char>=? c #\a)
      (char<=? c #\z)
      #f))

(define (char-upcase c)
  (if (char-lower-case? c)
      (integer->char (- (char->integer c) 32))
      c))

(define (char-downcase c)
  (if (char-upper-case? c)
      (integer->char (+ (char->integer c) 32))
      c))

(define (string-fill! str c)
  (for-each 
    (lambda (i) (string-set! str i c))
    (range 0 (string-length str))))

(define (make-string n . rest)
  (if (pair? rest)
      (begin
        (define ret (sys:make-string n))
        (string-fill! ret (car rest))
        ret)
      (sys:make-string n)))

(define (string-copy str)
  (define ret (make-string (string-length str)))
  (for-each 
    (lambda (i) (string-set! ret i (string-ref str i)))
    (range 0 (string-length str)))
  ret)

(define (string->list str)
  (define (iter acc index)
    (if (< index 0)
        acc
        (iter (cons (string-ref str index) acc) (- index 1))))
  (iter nil (- (string-length str) 1)))

(define (list->string lst)
  (define len (length lst))
  (define ret (make-string len))
  (define (copy index)
    (string-set! ret index (car lst))
    (set! lst (cdr lst)))
  (for-each copy (range 0 len))
  ret)
  
(define (string . values)
  (list->string values))

(define (string->number n . rest)
  (if (pair? rest)
      (sys:strtonum n (car rest))
      (sys:strtonum n 10)))

(define (number->string n . rest)
  (if (pair? rest)
      (sys:numtostr n (car rest))
      (sys:numtostr n 10)))

(define (append . lsts)
  (define (iter acc current)
    (if (pair? current)
        (iter (cons (car current) acc) (cdr current))
        acc))
  (reverse (fold iter nil lsts)))

(define (sort lst f)
  (if (pair? lst)
      (begin
        (define pivot (car lst))
        (define smaller-part (filter (lambda (x) (f x pivot)) (cdr lst)))
        (define larger-part (filter (lambda (x) (not (f x pivot))) (cdr lst)))
        (append (sort smaller-part f) (list pivot) (sort larger-part f)))
      lst))

(define (sys:string->character-source str position)
  (define (get)
    (if (< position (string-length str))
        (begin
          (set! position (+ position 1))
          (string-ref str (- position 1)))
        'eof))
  (define (peek)
    (if (< position (string-length str))
        (string-ref str position)
        'eof))
  (lambda (command)
    (cond ((eq? command 'get) get)
          ((eq? command 'peek) peek)
          (else (lambda () 'invalid-command-to-character-source)))))

(define (sys:read-from-character-source src)
  (define (skip-whitespace)
    (cond ((eq? ((src 'peek)) 'eof) 'eof)
          ((char-whitespace? ((src 'peek)))
            ((src 'get))
            (skip-whitespace))
          (else #t)))
  (define (skip-comment)
    (cond ((eq? ((src 'peek)) 'eof) 'eof)
          ((char=? #\newline ((src 'get))) #t)
          (else (skip-comment))))
  (define (read-symbol prefix)
    (define s (read-identifier prefix))
    (cond ((string=? s "#f") #f)
          ((string=? s "#t") #t)
          ((all? number-char? (string->list s)) (string->number s))
          (else (string->symbol s))))
  (define (read-special)
    (cond ((eq? ((src 'peek)) 'eof) (error "Unexpected end of stream"))
          ((char=? ((src 'peek)) #\\) (read-char))
          (else (read-symbol "#"))))
  (define (read-identifier acc)
    (define c ((src 'peek)))
    (cond ((eq? c 'eof) acc)
          ((char=? c #\)) acc)
          ((char-whitespace? c) acc)
          (else (read-identifier (string-append acc (string ((src 'get))))))))
  (define (read-alphabetic-char)
    (define s (read-identifier ""))
    (cond ((string=? s "space") #\space)
          ((string=? s "tab") #\tab)
          ((string=? s "newline") #\newline)
          ((string=? s "cr") #\cr)
          ((= 1 (string-length s)) (string-ref s 0))
          (else (error (string-append "Invalid character name " s)))))
  (define (read-char)
    ((src 'get))
    (define c ((src 'peek)))
    (cond ((eq? c 'eof) (error "Unexpected end of stream"))
          ((char-alphabetic? c) (read-alphabetic-char))
          (else ((src 'get)))))
  (define (read-list acc)
    (skip-whitespace)
    (define c ((src 'peek)))
    (cond ((eq? c 'eof) (error "Unexpected end of stream"))
          ((char=? c #\)) ((src 'get)) (reverse acc))
          (else (read-list (cons (sys:read-from-character-source src) acc)))))
  (define (read-string acc)
    (define c ((src 'get)))
    (cond ((eq? c 'eof) (error "Unexpected end of stream"))
          ((char=? c #\") acc)
          ((char=? c #\\)
            (set! c ((src 'get)))
            (cond ((eq? c 'eof) (error "Unexpected end of stream"))
                  ((char=? c #\n) (set! c #\newline))
                  (else #t))
            (read-string (string-append acc (string c))))
          (else (read-string (string-append acc (string c))))))
  (define (number-char? c)
    (if (char-numeric? c)
        #t
        (char=? c #\.)))
  (skip-whitespace)
  (define c ((src 'peek)))
  (cond ((eq? c 'eof) nil)
        ((char=? c #\;) (skip-comment) (sys:read-from-character-source src))
        ((char=? c #\#) ((src 'get)) (read-special))
        ((char=? c #\') ((src 'get)) (list 'quote (sys:read-from-character-source src)))
        ((char=? c #\() ((src 'get)) (read-list nil))
        ((char=? c #\") ((src 'get)) (read-string ""))
        (else (read-symbol ""))))

(define (sys:read-all-from-string str)
  (define (cons-unless-nil a b)
    (if (null? a)
        b
        (cons a b)))
  (define (iter acc src)
    (if (eq? 'eof ((src 'peek)))
        (reverse acc)
        (iter (cons-unless-nil (sys:read-from-character-source src) acc) src)))
  (iter nil (sys:string->character-source str 0)))
